<!doctype html>
<html lang="zh-CN">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
	<title>坦克大战</title>
	<style>
		* { box-sizing: border-box; }
		html, body { margin: 0; height: 100%; background: #0f1221; color: #e6e9f0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; }
		#ui {
			position: fixed; inset: 0; pointer-events: none; display: grid; grid-template-rows: auto 1fr auto; padding: 12px; gap: 8px; 
			background: radial-gradient(1200px 600px at 50% -200px, rgba(255,255,255,0.06), transparent 70%);
		}
		#topBar { display: flex; align-items: center; justify-content: space-between; gap: 12px; pointer-events: auto; }
		.brand { font-weight: 700; letter-spacing: 0.5px; color: #99e9ff; text-shadow: 0 0 10px rgba(0, 200, 255, 0.25); }
		.controls { display: flex; align-items: center; gap: 8px; }
		.button { appearance: none; border: 0; cursor: pointer; pointer-events: auto; padding: 8px 12px; border-radius: 8px; background: linear-gradient(#2a2f4a, #1b2038); color: #e6e9f0; box-shadow: inset 0 1px 0 rgba(255,255,255,0.06), 0 6px 20px rgba(0,0,0,0.3); }
		.button:active { transform: translateY(1px); }
		.stats { display: flex; gap: 12px; font-variant-numeric: tabular-nums; }
		.badge { padding: 4px 8px; border-radius: 999px; background: #18213a; border: 1px solid #263056; color: #b8c4ff; }
		#hud { align-self: end; display: flex; justify-content: space-between; pointer-events: none; font-variant-numeric: tabular-nums; }
		.hud-left, .hud-right { display: flex; gap: 12px; align-items: center; }
		#help { pointer-events: auto; background: rgba(16, 22, 44, 0.8); border: 1px solid #2a3766; border-radius: 12px; padding: 10px 12px; color: #c6d2ff; max-width: 520px; line-height: 1.5; }
		kbd { background: #1a2444; border: 1px solid #2a3766; padding: 2px 6px; border-radius: 6px; box-shadow: inset 0 1px 0 rgba(255,255,255,0.05); }
		#centerMsg { position: fixed; left: 50%; top: 50%; transform: translate(-50%, -50%); pointer-events: none; text-align: center; }
		#centerMsg .title { font-size: 48px; font-weight: 800; letter-spacing: 1px; color: #9be1ff; text-shadow: 0 10px 30px rgba(0, 195, 255, 0.3); }
		#centerMsg .subtitle { margin-top: 8px; color: #c6d2ff; }
		canvas { display: block; width: 100vw; height: 100vh; }
	</style>
</head>
<body>
	<canvas id="game"></canvas>
	<div id="ui">
		<div id="topBar">
			<div class="brand">坦克大战</div>
			<div class="controls">
				<button class="button" id="btnStart">开始/重开 (R)</button>
				<button class="button" id="btnPause">暂停/继续 (P)</button>
				<span class="stats">
					<span class="badge">分数 <span id="score">0</span></span>
					<span class="badge">关卡 <span id="wave">1</span></span>
					<span class="badge">生命 <span id="lives">3</span></span>
				</span>
			</div>
					</div>
		<div id="hud">
			<div class="hud-left">
				<div id="help">
					操作：<kbd>WASD</kbd> 或 方向键 移动，<kbd>J</kbd>/<kbd>空格</kbd> 射击，<kbd>P</kbd> 暂停，<kbd>R</kbd> 重开
			</div>
					</div>
			<div class="hud-right"></div>
					</div>
				</div>
	<div id="centerMsg" hidden>
		<div class="title" id="bigTitle">GAME OVER</div>
		<div class="subtitle" id="smallTitle">按 R 重开</div>
	</div>

	<script>
		// ===== Canvas & Utils =====
		const canvas = document.getElementById('game');
		const ctx = canvas.getContext('2d');
		const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
		const world = { w: 960, h: 540 };
		function resize() {
			const { innerWidth: vw, innerHeight: vh } = window;
			canvas.width = Math.floor(vw * dpr);
			canvas.height = Math.floor(vh * dpr);
			canvas.style.width = vw + 'px';
			canvas.style.height = vh + 'px';
			ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
			world.w = vw; world.h = vh;
		}
		resize();
		window.addEventListener('resize', resize);

		function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
		function rand(a, b){ return a + Math.random() * (b - a); }
		function now(){ return performance.now(); }

		// ===== Input =====
		const keys = new Set();
		const keyMap = {
			ArrowUp: 'up', ArrowDown: 'down', ArrowLeft: 'left', ArrowRight: 'right',
			w: 'up', a: 'left', s: 'down', d: 'right',
			W: 'up', A: 'left', S: 'down', D: 'right',
			' ': 'fire', j: 'fire', J: 'fire'
		};
		window.addEventListener('keydown', (e) => {
			const m = keyMap[e.key];
			if (m) { keys.add(m); e.preventDefault(); }
			if (e.key === 'p' || e.key === 'P') togglePause();
			if (e.key === 'r' || e.key === 'R') startGame();
		});
		window.addEventListener('keyup', (e) => {
			const m = keyMap[e.key];
			if (m) keys.delete(m);
		});

		// ===== Game State =====
		const ui = {
			score: document.getElementById('score'),
			wave: document.getElementById('wave'),
			lives: document.getElementById('lives'),
			center: document.getElementById('centerMsg'),
			big: document.getElementById('bigTitle'),
			small: document.getElementById('smallTitle'),
			btnStart: document.getElementById('btnStart'),
			btnPause: document.getElementById('btnPause'),
		};
		ui.btnStart.addEventListener('click', () => startGame());
		ui.btnPause.addEventListener('click', () => togglePause());

		const colors = {
			bg: '#0f1221', grid: '#1a1f3a', wall: '#273055',
			player: '#7be0a5', enemy: '#ff7b9c', bulletP: '#a2ffe3', bulletE: '#ffc2d0',
			pickupHp: '#7be0ff', pickupRapid: '#ffd166', pickupSpecial: '#b388ff'
		};

		const state = {
			started: false,
			paused: false,
			score: 0,
			wave: 1,
			lives: 5,
			lastFireAt: 0,
			enemies: [],
			bullets: [],
			pickups: [],
			walls: [],
			spawnTimer: 0,
			spawnInterval: 1800,
			player: null,
			rapidUntil: 0,
			specialAmmo: 0
		};

		// ===== Entities =====
		function createPlayer() {
			return {
				x: world.w * 0.5,
				y: world.h * 0.8,
				w: 38,
				h: 38,
				angle: -Math.PI / 2,
				speed: 200,
				reloadMs: 160,
				hp: 3
			};
		}

		function createEnemy() {
			const isBig = Math.random() < clamp(0.2 + state.wave * 0.03, 0.2, 0.7);
			const size = isBig ? rand(48, 64) : rand(28, 40);
			const side = Math.random() < 0.5 ? 'h' : 'v';
			const x = side === 'h' ? (Math.random() < 0.5 ? 40 : world.w - 40) : rand(40, world.w - 40);
			const y = side === 'v' ? (Math.random() < 0.5 ? 40 : world.h - 40) : rand(40, world.h * 0.35);
			return {
				x, y, w: size, h: size,
				angle: Math.atan2(state.player.y - y, state.player.x - x),
				speed: isBig ? rand(40, 80) : rand(80, 140),
				reloadMs: rand(700, 1200),
				lastFireAt: 0,
				hp: isBig ? 3 + Math.floor(state.wave * 0.3) : 1 + Math.floor(state.wave * 0.2),
				type: isBig ? 'big' : 'small'
			};
		}

		function fireBullet(owner, isEnemy) {
			const speed = isEnemy ? 360 : 440;
			const spread = isEnemy ? rand(-0.08, 0.08) : 0;
			const angle = owner.angle + spread;
			const bx = owner.x + Math.cos(angle) * (owner.w * 0.6);
			const by = owner.y + Math.sin(angle) * (owner.h * 0.6);
			if (!isEnemy && state.specialAmmo > 0) {
				state.specialAmmo -= 1; updateHud();
				state.bullets.push({ x: bx, y: by, r: 6, angle, speed: speed + 60, ttl: 2600, enemy: false, dmg: 2, pierce: 2, special: true });
			} else {
				state.bullets.push({ x: bx, y: by, r: 4, angle, speed, ttl: 2200, enemy: isEnemy, dmg: 1, pierce: 0 });
			}
		}

		function buildWalls() {
			state.walls = [];
			const pad = 60;
			const cols = 5, rows = 3;
			const cellW = (world.w - pad * 2) / (cols - 1);
			const yTop = world.h * 0.35;
			for (let r = 0; r < rows; r++) {
				for (let c = 0; c < cols; c++) {
					const w = 60, h = 18;
					const x = pad + c * cellW;
					const y = yTop + r * 64;
					state.walls.push({ x, y, w, h, hp: 3 });
				}
			}
		}

		// ===== Collision Helpers =====
		function rectsOverlap(a, b) {
			return Math.abs(a.x - b.x) * 2 < (a.w + b.w) && Math.abs(a.y - b.y) * 2 < (a.h + b.h);
		}
		function pointInRect(px, py, r){ return px > r.x - r.w/2 && px < r.x + r.w/2 && py > r.y - r.h/2 && py < r.y + r.h/2; }

		// ===== Rendering =====
		function drawGrid() {
			ctx.fillStyle = colors.bg;
			ctx.fillRect(0, 0, world.w, world.h);
			ctx.strokeStyle = colors.grid;
			ctx.lineWidth = 1;
			ctx.globalAlpha = 0.6;
			const step = 32;
			ctx.beginPath();
			for (let x = 0; x < world.w; x += step) { ctx.moveTo(x + 0.5, 0); ctx.lineTo(x + 0.5, world.h); }
			for (let y = 0; y < world.h; y += step) { ctx.moveTo(0, y + 0.5); ctx.lineTo(world.w, y + 0.5); }
			ctx.stroke();
			ctx.globalAlpha = 1;
		}

		function drawTank(t, color) {
			ctx.save();
			ctx.translate(t.x, t.y);
			ctx.rotate(t.angle);
			ctx.fillStyle = color; ctx.strokeStyle = '#000'; ctx.lineWidth = 2; 
			ctx.beginPath();
			ctx.roundRect(-t.w/2, -t.h/2, t.w, t.h, 6);
			ctx.fill(); ctx.stroke();
			// turret
			ctx.fillStyle = '#ffffff22';
			ctx.beginPath(); ctx.arc(0, 0, Math.min(t.w, t.h)/3, 0, Math.PI*2); ctx.fill();
			// barrel
			ctx.fillStyle = color;
			ctx.fillRect(t.w/2 - 6, -4, Math.max(14, t.w*0.5), 8);
			ctx.restore();
		}

		function drawWalls() {
			for (const w of state.walls) {
				ctx.save();
				ctx.translate(w.x, w.y);
				ctx.fillStyle = colors.wall;
				ctx.strokeStyle = '#000';
				ctx.lineWidth = 2;
				ctx.globalAlpha = clamp(w.hp / 3, 0.35, 1);
				ctx.beginPath();
				ctx.roundRect(-w.w/2, -w.h/2, w.w, w.h, 4);
				ctx.fill(); ctx.stroke();
				ctx.globalAlpha = 1;
				ctx.restore();
			}
		}

		function drawBullets() {
			for (const b of state.bullets) {
				ctx.save();
				ctx.translate(b.x, b.y);
				ctx.fillStyle = b.enemy ? colors.bulletE : (b.special ? '#e0d7ff' : colors.bulletP);
				ctx.shadowColor = ctx.fillStyle; ctx.shadowBlur = 10;
				ctx.beginPath(); ctx.arc(0, 0, b.r, 0, Math.PI*2); ctx.fill();
				ctx.restore();
			}
			ctx.shadowBlur = 0;
		}

		function drawPickups() {
			for (const p of state.pickups) {
				ctx.save();
				ctx.translate(p.x, p.y);
				ctx.fillStyle = p.kind === 'hp' ? colors.pickupHp : (p.kind === 'rapid' ? colors.pickupRapid : colors.pickupSpecial);
				ctx.strokeStyle = '#000'; ctx.lineWidth = 2;
				const s = 18;
				ctx.beginPath(); ctx.roundRect(-s/2, -s/2, s, s, 4); ctx.fill(); ctx.stroke();
				ctx.fillStyle = '#0b0f1f';
				ctx.font = '12px sans-serif'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
				ctx.fillText(p.kind === 'hp' ? 'H' : p.kind === 'rapid' ? 'R' : 'S', 0, 1);
				ctx.restore();
			}
		}

		// ===== Update =====
		function updatePlayer(dt) {
			const p = state.player; if (!p) return;
			let vx = 0, vy = 0;
			if (keys.has('left')) vx -= 1;
			if (keys.has('right')) vx += 1;
			if (keys.has('up')) vy -= 1;
			if (keys.has('down')) vy += 1;
			if (vx !== 0 || vy !== 0) {
				const len = Math.hypot(vx, vy) || 1;
				vx = vx / len; vy = vy / len;
				p.x += vx * p.speed * dt; p.y += vy * p.speed * dt;
				p.angle = Math.atan2(vy, vx);
			}
			p.x = clamp(p.x, p.w/2 + 8, world.w - p.w/2 - 8);
			p.y = clamp(p.y, p.h/2 + 8, world.h - p.h/2 - 8);
			const effectiveReload = now() < state.rapidUntil ? Math.max(80, p.reloadMs * 0.5) : p.reloadMs;
			if (keys.has('fire') && now() - state.lastFireAt > effectiveReload) {
				state.lastFireAt = now();
				fireBullet(p, false);
			}
			for (const w of state.walls) {
				if (rectsOverlap(p, w)) {
					if (p.x < w.x) p.x = w.x - w.w/2 - p.w/2;
					if (p.x > w.x) p.x = w.x + w.w/2 + p.w/2;
					if (p.y < w.y) p.y = w.y - w.h/2 - p.h/2;
					if (p.y > w.y) p.y = w.y + w.h/2 + p.h/2;
				}
			}
			// pickup collection
			for (let i = state.pickups.length - 1; i >= 0; i--) {
				const pk = state.pickups[i];
				if (pointInRect(p.x, p.y, { x: pk.x, y: pk.y, w: 24, h: 24 })) {
					applyPickup(pk);
					state.pickups.splice(i,1);
				}
			}
		}

		function updateEnemies(dt, t) {
			for (let i = state.enemies.length - 1; i >= 0; i--) {
				const e = state.enemies[i];
				e.angle = Math.atan2(state.player.y - e.y, state.player.x - e.x);
				e.x += Math.cos(e.angle) * e.speed * dt;
				e.y += Math.sin(e.angle) * e.speed * dt;
				// walls pushback
				for (const w of state.walls) {
					if (rectsOverlap(e, w)) {
						if (e.x < w.x) e.x = w.x - w.w/2 - e.w/2;
						if (e.x > w.x) e.x = w.x + w.w/2 + e.w/2;
						if (e.y < w.y) e.y = w.y - w.h/2 - e.h/2;
						if (e.y > w.y) e.y = w.y + w.h/2 + e.h/2;
					}
				}
				// fire
				if (t - e.lastFireAt > e.reloadMs) {
					e.lastFireAt = t;
					fireBullet(e, true);
				}
				// hit player
				if (rectsOverlap(e, state.player)) {
					if (e.type === 'small') {
						// crush small tank
						boom(e.x, e.y);
						spawnDrops(e);
						state.enemies.splice(i, 1);
						state.score += 100;
					} else {
						boom(e.x, e.y);
						state.enemies.splice(i, 1);
						loseLife();
					}
				}
			}
		}

		function updateBullets(dt) {
			for (let i = state.bullets.length - 1; i >= 0; i--) {
				const b = state.bullets[i];
				b.x += Math.cos(b.angle) * b.speed * dt;
				b.y += Math.sin(b.angle) * b.speed * dt;
				b.ttl -= dt * 1000;
				if (b.x < -10 || b.x > world.w + 10 || b.y < -10 || b.y > world.h + 10 || b.ttl <= 0) { state.bullets.splice(i,1); continue; }
				// walls
				let removed = false;
				for (let wi = state.walls.length - 1; wi >= 0; wi--) {
					const w = state.walls[wi];
					if (pointInRect(b.x, b.y, w)) {
						state.bullets.splice(i,1); removed = true;
						w.hp -= 1; if (w.hp <= 0) state.walls.splice(wi,1);
						break;
					}
				}
				if (removed) continue;
				if (b.enemy) {
					const p = state.player;
					if (pointInRect(b.x, b.y, p)) {
						state.bullets.splice(i,1);
						boom(p.x, p.y);
						loseLife();
					}
				} else {
					for (let ei = state.enemies.length - 1; ei >= 0; ei--) {
						const e = state.enemies[ei];
						if (pointInRect(b.x, b.y, e)) {
							const dmg = b.dmg || 1;
							e.hp -= dmg;
							if (e.hp <= 0) {
								spawnDrops(e);
								state.enemies.splice(ei,1); state.score += 100;
							}
							if (b.pierce && b.pierce > 0) { b.pierce -= 1; }
							else { state.bullets.splice(i,1); removed = true; }
							break;
						}
					}
				}
			}
		}

		function spawnDrops(enemy) {
			if (enemy.type === 'small') {
				// drop hp and rapid
				state.pickups.push({ x: enemy.x - 10, y: enemy.y, kind: 'hp' });
				state.pickups.push({ x: enemy.x + 10, y: enemy.y, kind: 'rapid' });
			} else {
				// big enemy drops special ammo
				state.pickups.push({ x: enemy.x, y: enemy.y, kind: 'special' });
			}
		}

		function applyPickup(pk) {
			if (pk.kind === 'hp') {
				state.lives = clamp(state.lives + 1, 0, 9);
				updateHud();
			} else if (pk.kind === 'rapid') {
				state.rapidUntil = now() + 6000; // 6s rapid fire
			} else if (pk.kind === 'special') {
				state.specialAmmo += 5;
				updateHud();
			}
		}

		// ===== Effects =====
		const sparks = [];
		function boom(x, y) {
			for (let i = 0; i < 14; i++) {
				sparks.push({ x, y, vx: rand(-160, 160), vy: rand(-160, 160), life: rand(200, 500)});
			}
		}
		function drawSparks(dt) {
			for (let i = sparks.length - 1; i >= 0; i--) {
				const s = sparks[i];
				s.x += s.vx * dt; s.y += s.vy * dt; s.vx *= 0.98; s.vy *= 0.98; s.life -= dt * 1000;
				if (s.life <= 0) { sparks.splice(i,1); continue; }
				ctx.fillStyle = '#ffd166'; ctx.globalAlpha = clamp(s.life / 500, 0, 1);
				ctx.fillRect(s.x, s.y, 3, 3);
			}
			ctx.globalAlpha = 1;
		}

		// ===== Waves & Lives =====
		function spawnWave() {
			const count = 3 + state.wave;
			for (let i = 0; i < count; i++) state.enemies.push(createEnemy());
			state.spawnInterval = clamp(1800 - state.wave * 60, 800, 1800);
		}
		function loseLife() {
			state.lives -= 1; ui.lives.textContent = state.lives;
			if (state.lives <= 0) return gameOver();
			// brief invulnerability by clearing nearby bullets
			state.bullets = state.bullets.filter(b => Math.hypot(b.x - state.player.x, b.y - state.player.y) > 80 || !b.enemy);
		}
		function gameOver() {
			state.started = false; state.paused = true;
			ui.center.hidden = false; ui.big.textContent = 'GAME OVER'; ui.small.textContent = '按 R 重开';
		}

		// ===== Loop =====
		let prev = now();
		function tick() {
			requestAnimationFrame(tick);
			const t = now();
			let dt = (t - prev) / 1000; prev = t;
			dt = Math.min(dt, 1/30);
			if (!state.started || state.paused) { drawGrid(); drawWalls(); drawSparks(0); if (state.player) drawTank(state.player, colors.player); for (const e of state.enemies) drawTank(e, colors.enemy); drawBullets(); return; }

			updatePlayer(dt);
			updateEnemies(dt, t);
			updateBullets(dt);
			state.spawnTimer += dt * 1000;
			if (state.enemies.length === 0 && state.spawnTimer > 400) {
				state.wave += 1; ui.wave.textContent = state.wave; spawnWave(); state.spawnTimer = 0;
			}

			drawGrid();
			drawWalls();
			for (const e of state.enemies) drawTank(e, colors.enemy);
			if (state.player) drawTank(state.player, colors.player);
			drawBullets();
			drawPickups();
			drawSparks(dt);

			updateHud();
		}
		requestAnimationFrame(tick);

		// ===== Controls =====
		function togglePause() {
			if (!state.started) return;
			state.paused = !state.paused;
			ui.center.hidden = state.paused ? false : true;
			ui.big.textContent = state.paused ? '暂停' : '';
			ui.small.textContent = state.paused ? '按 P 继续' : '';
		}
		function startGame() {
			state.started = true; state.paused = false; state.score = 0; state.wave = 1; state.lives = 5; ui.wave.textContent = 1; ui.lives.textContent = 5; ui.center.hidden = true; state.enemies = []; state.bullets = []; state.pickups = []; sparks.length = 0; state.specialAmmo = 0; state.rapidUntil = 0;
			state.player = createPlayer();
			buildWalls();
			spawnWave();
			prev = now();
		}

		function updateHud() {
			ui.score.textContent = state.score;
			ui.lives.textContent = state.lives;
			// dynamic hint of special ammo / rapid
			let right = document.querySelector('.hud-right');
			right.innerHTML = '';
			const mk = (label) => { const s = document.createElement('span'); s.className = 'badge'; s.textContent = label; return s; };
			if (state.specialAmmo > 0) right.appendChild(mk('特色弹 ' + state.specialAmmo));
			if (now() < state.rapidUntil) {
				const leftMs = Math.max(0, Math.ceil((state.rapidUntil - now())/1000));
				right.appendChild(mk('速射 ' + leftMs + 's'));
			}
		}

		// start with splash
		ui.center.hidden = false;
		ui.big.textContent = '坦克大战';
		ui.small.textContent = '按 R 开始';
	</script>
</body>
</html>


